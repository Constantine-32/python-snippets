import logging

from .hanoi_exception import HanoiException
from .state import State
from .tower import Tower

logging.basicConfig(level=logging.INFO, format='%(levelname)-10s  %(message)s')


class HanoiGame:
    """
    Main class for management of the data structures and moves of the game.
    """

    def __init__(self, n_discs, n_towers=3):
        """
        Initializes the game with n_discs and n_towers, which defaults to 3.
        At this step, the game can be solved and stored to consult.

        Raises a HanoiException if n_discs is negative or n_towers is less than 3.

        :param n_discs: Number of disks for this game.
        :param n_towers: Number of towers for this game. Default: 3
        """

        # Steps:
        # 1.- Check the parameters (Add the code after this comment)
        if n_discs < 0:
            raise HanoiException('The number of discs must be a positive value.')

        if n_towers < 3:
            raise HanoiException('The number of towers must be at least 3.')

        # 2.- Initialize the structure attributes (Add the code after this comment)
        self.n_discs = n_discs
        self.n_towers = n_towers

        # 3.- Initialize the towers (Add the code after this comment)
        self.towers = self._init_towers()

        self.state = State(None, None, None, None, None, self.towers, n_discs)
        self.states = [self.state]

        # 4.- Solve and store the optimal solution
        self._solve()

    def get_state(self, step):
        """
        Returns the state at the requested step in the optimal solution.
        Raises a HanoiException if the step index is negative or bigger than the total of states in the optimal
        solution.

        :param step: The step index in the optimal solution.
        :return: The state at the requested step in the optimal solution.
        """
        try:
            return self.states[step]
        except IndexError:
            raise HanoiException('Step index out of range')

    def get_n_discs(self):
        """
        Returns the number of disks of this game.

        :return: The number of disks of this game.
        """
        return self.n_discs

    def get_n_towers(self):
        """
        Returns the number of towers of this game.

        :return: The number of towers of this game.
        """
        return self.n_towers

    def get_n_states(self):
        """
        Returns the number of states of the optimal solution. Ideally, it should be the size of the structure used to
        store the optimal solution states.
        Raises a HanoiException if the size of the structure used to store the optimal solution states is different
        from the calculed optimal stepts (2 ** n_discs).

        :return: The number of states of the optimal solution.
        """
        number_states = len(self.states)
        if number_states != 2 ** self.n_discs:
            raise HanoiException('Apparently optimal solution is not optimal.')
        return number_states

    def move(self, source, target, move_id=None, depth=None):
        """
        Moves a disk from source tower to target tower.
        Raises a HanoiException if source and target are the same or if the move is invalid (the disk moved is bigger
        than the last disk in the target tower, the source tower is empty...)

        :param source: Tower from which a disk is going to be moved.
        :param target: Tower to which a disk is going to be moved.
        :param move_id: Identifier of the movement. Useful as information for the optimal state.
        :param depth: Depth of the recursion call. Useful as information for the optimal state.
        :return: The new state generated by the move.
        """
        if source == target:
            raise HanoiException('Source and target towers cannot be the same.')

        moved_disc = self.towers[source].pop_disc()
        self.towers[target].push_disc(moved_disc)

        new_state = State(move_id, depth, moved_disc, source, target, self.towers, self.n_discs)
        if move_id is None and depth is None:
            self.state = new_state

        return new_state

    def _solve(self):
        """
        Generates and stores the optimal solution, reinitializing the towers afterwards.
        """
        source, aux, target = 0, 1, 2
        self._solve_rec(self.n_discs, source, target, aux, 1)
        self.towers = self._init_towers()

    def _solve_rec(self, n_discs, source, target, aux, depth=0):
        """
        Recursive call to solve the hanoi game optimally.

        :param n_discs: Number of disks to be moved.
        :param source: Tower from which a disk is going to be moved.
        :param target: Tower to which a disk is going to be moved.
        :param aux: Tower to be used as auxiliary.
        :param depth: Depth of the recursion call. Useful as information for the optimal state.
        """
        if n_discs > 0:
            self._solve_rec(n_discs - 1, source, aux, target, depth + 1)
            self.states.append(self.move(source, target, len(self.states), depth))
            self._solve_rec(n_discs - 1, aux, target, source, depth + 1)

    def print_optimal_state(self, step):
        """
        Prints the optimal state at the selected step in the required format.

        :param step: Step index of the optimal solution.
        """
        print(self.get_state(step))

    def print_optimal_solution(self):
        """
        Prints all the states of the optimal solution in the required format.
        """
        for state in self.states:
            print(state)

    def is_finished(self):
        """
        Checks if the interactive game is finished, returns True if is finished, False otherwise.

        :return: True if the game is finished, False otherwise.
        """
        return self.towers[-1].size() == self.n_discs

    def get_current_state(self):
        """
        Returns the current state of the game.

        :return: The current state of the game.
        """
        return self.state

    def _init_towers(self):
        """
        Returns a list of Towers of length n_towers initializing the first one with n_discs discs.

        :return: A list of Towers initialized according to n_towers and n_discs.
        """
        towers = [Tower() for _ in range(self.n_towers)]
        for disc in range(self.n_discs, 0, -1):
            towers[0].push_disc(disc)
        return towers

    def __repr__(self):
        """
        Returns a string with the internal representation of the game. This method can be used to represent the game
        information in a different format than the requested.

        :return: A string with the internal representation of the game.
        """
        return str(self)

    def __str__(self):
        """
        Returns a string with the representation of the current state of the game in the requested format.

        :return: A string with the representation of the current state of the game in the requested format.
        """
        return str(self.get_current_state())
